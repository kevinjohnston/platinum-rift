;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; INPUT ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 playerCount
 myid
 zoneCount
 linkCount
loop zoneCount
 zoneId
 platinumSource
loop linkCount ;;tells how zones are connected
 zone1
 zone2

 platinum ;;my current plat
loop zoneCount
 zId ;;zone id
 ownerId ;;current owner of zone or -1
 podsP0
 podsP1
 podsP2
 podsP3



;;strategy types
random -- monte carlo, search win (may be hard to seed choices, opponent won't play randomly)
weighted priorities -- hardcoded weights for wanting to control continents, reducing liberties, maximizing income, minimizing enemy territory, etc
tit for tat -- respond to opponents apparent strategy (erasers to track and follow opponents pods)
opportunist -- acts randomly but tries to identify weak spots in opponents position (i.e. isolated easily trapped pod)
multi-armed-general -- tries different strategies at random and tries to converge on the one that provides this biggest percent lead over the opponent

;;;;;helper code
;;in game
traveling salesman -- move between each platinum node as quickly as possible
advisor -- evaluates postion (i.e. decides if you have high or low income, weak or strong board positions)
rest -- be able to 'rest' board evaluation functions for a number of turns to spend processor time elsewhere

;;out of game
script to combine source code files in a directory for easy copy/paste to browser



;;;;Abstractions
zone-sets -- groups of territories (or single territories)
strategies -- functions that change overview
tactics -- functions that can change zone-sets
advisors -- functions that can evaluate zone-sets


;;simple strategies
go straight for biggest payoff platinum nodes
capture small continents early for secure income
capture and hold chokepoints between continents
penetrate opponents territory in pairs to slow defenses
select areas to cede to an opponent and aggressively target others
maximize territory to surface area
go after less productive platinum square to reduce competition



;;zone-set
{
:id (zone-id or  1000+)
:sub-zones #{ (set of zone-ids)}
:priority (int to indicate how important this territory is to the strategy gets re-evaluated from time to time)
:last-eval (turn priority was last set)
:value (accumulated total of platinum bars in all sub-zones)
:total-liberties (total number of adjacent zones)
:open-liberties (number of adjacent zones that aren't controlled by you)
}


;;strategies
{
  :last-eval (last turn strategy was evaluated)
  :evaluation (num last evaulation of overall strategy by advisor)

}

(fn strat1
 [zone-set ;;the zone set to apply the strat to
 ]
)

;strat-list:
defend (defend sensitive positions)
erase (follow enemy pods around taking old territory)
blitz (run as deep into enemy territory as possible)
greed (take as many valuable resource locations as possible as quickly as possible)
herd (try to force enemies to move to bad positions)
save (stockpile plat)
surge (spend all plat)
cede (decide not to pursue certain zones)






;;misc helper fun
forget-about-it (remove continents that are claimed entirely by me or by other players)
advance-game (adjust whether the game is considered early, mid, or late)



;strategy is about what desired board result will look like in x turns
;tactics are the methods that can be applied to zone-sets to try to achieve a strategy


;;program flow
...hard code turn 1-10 strategy...
then...
pick strategy for each continent (at random at first, then based on past successes of the strat)
assign priorities to each zone based on the strategy
pick tactics recursively for each zone in the continent




;;testing
create world (NA)
pick some strategy (raise income)
assign tactics to each zone (take high plat areas)



strategy -- set of functions to set desired game state
tactic -- function to modify game state


(defn tactic-place-unit-on-res [board-state]
;;find highest value res
;;place unit
;;return new state
)

(defn tactic-move-unit-to-res [board-state]
;;find highest value res
;;find closest unit
;;move unit towards res
;;return new state
)


(loop [iterate-board-state current-state
       acc-tactics []]
(if (empty? (all-available-tactics))
    acc-tactics
(let [choosen-tactic (first (sort evaluate-board-state (all-available-tactics)))]
(recur choosen-tactic-result
    choosen-tactic))))

;;accumlate best available tactics










;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Alt approach ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


agenda -- priorities for game state (player metrics)
personality -- quantifies how to treat metrics (enemies should be avoided,
strategy -- priorities for board state (board metrics)
tactics -- how to achive board state (considered strategy and personality)



(fn was-agenda-successful?
(loop [goals @goals
       success 0] {:goal (fn [player-state] (>= 20 (:platinum player-state))) :priority [0-3] }
   (recur
 (next goals)
(+ success
  (* ((first (first goal)) player-state) priority))))




personality
{
:aggressive 1-10
:frugal 1-10
:defensive 1-10
:daring 1-10 (don't avoid enemy territory)
}


strategy
{
:maximize-territory 1-10
:get-plat 1-10
:minimize-liberties 1-10
:exploit-weakness
}

(defprotocal tactics
(filter-map [personality, strategy] "Function to adjust graph-map, removing occupied or near occupied territory")

)





ultimately all decisions boil down to moving things or placing things (or neither)





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Heat approach ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
create 'advisors' each evaluating a nodes importance (tactician, banker, defender, ...)
advisors weights for each node sum or multiply to create a heat map
iterate over available actions such as placing new pods or moving units and review which results in biggest gain, apply and eval next action


(advise advisor @global-map) ;;returns vector of vectors, one for each game node giving a priority to the nodes [[:node-id :priority-num] [...]...]
(sum-advice)
(while has-more-actions
    (do-best (sort compare (move-nearest :highest-priority-node) (place-near :highest-priority-node))))
(evalutate-game-state-better-worse-and-adjust-advisor-influence)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Monte Carlo approach ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
after first turn of placing pods on ten highest income sites (or some randomly amongst income sites)
try to play as many games as possible and determine which moves are most likely to result in success, make random moves (possibly weighted towards moving to income squares), model opponent as always moving towards highest empty resource square
