;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; INPUT ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 playerCount
 myid
 zoneCount
 linkCount
loop zoneCount
 zoneId
 platinumSource
loop linkCount ;;tells how zones are connected
 zone1
 zone2

 platinum ;;my current plat
loop zoneCount
 zId ;;zone id
 ownerId ;;current owner of zone or -1
 podsP0
 podsP1
 podsP2
 podsP3



;;strategy types
random -- monte carlo, search win (may be hard to seed choices, opponent won't play randomly)
weighted priorities -- hardcoded weights for wanting to control continents, reducing liberties, maximizing income, minimizing enemy territory, etc
tit for tat -- respond to opponents apparent strategy (erasers to track and follow opponents pods)
opportunist -- acts randomly but tries to identify weak spots in opponents position (i.e. isolated easily trapped pod)
multi-armed-general -- tries different strategies at random and tries to converge on the one that provides this biggest percent lead over the opponent

;;;;;helper code
;;in game
traveling salesman -- move between each platinum node as quickly as possible
advisor -- evaluates postion (i.e. decides if you have high or low income, weak or strong board positions)
rest -- be able to 'rest' board evaluation functions for a number of turns to spend processor time elsewhere

;;out of game
script to combine source code files in a directory for easy copy/paste to browser



;;;;Abstractions
zone-sets -- groups of territories (or single territories)
strategies -- functions that change overview
tactics -- functions that can change zone-sets
advisors -- functions that can evaluate zone-sets


;;simple strategies
go straight for biggest payoff platinum nodes
capture small continents early for secure income
capture and hold chokepoints between continents
penetrate opponents territory in pairs to slow defenses
select areas to cede to an opponent and aggressively target others
maximize territory to surface area
go after less productive platinum square to reduce competition



;;zone-set
{
:id (zone-id or  1000+)
:sub-zones #{ (set of zone-ids)}
:priority (int to indicate how important this territory is to the strategy gets re-evaluated from time to time)
:last-eval (turn priority was last set)
:value (accumulated total of platinum bars in all sub-zones)
:total-liberties (total number of adjacent zones)
:open-liberties (number of adjacent zones that aren't controlled by you)
}


;;strategies
{
  :last-eval (last turn strategy was evaluated)
  :evaluation (num last evaulation of overall strategy by advisor)

}

(fn strat1
 [zone-set ;;the zone set to apply the strat to
 ]
)

;strat-list:
defend (defend sensitive positions)
erase (follow enemy pods around taking old territory)
blitz (run as deep into enemy territory as possible)
greed (take as many valuable resource locations as possible as quickly as possible)
herd (try to force enemies to move to bad positions)
save (stockpile plat)
surge (spend all plat)
cede (decide not to pursue certain zones)






;;misc helper fun
forget-about-it (remove continents that are claimed entirely by me or by other players)
advance-game (adjust whether the game is considered early, mid, or late)



;strategy is about what desired board result will look like in x turns
;tactics are the methods that can be applied to zone-sets to try to achieve a strategy


;;program flow
...hard code turn 1-10 strategy...
then...
pick strategy for each continent (at random at first, then based on past successes of the strat)
assign priorities to each zone based on the strategy
pick tactics recursively for each zone in the continent




;;testing
create world (NA)
pick some strategy (raise income)
assign tactics to each zone (take high plat areas)



strategy -- set of functions to set desired game state
tactic -- function to modify game state


(defn tactic-place-unit-on-res [board-state]
;;find highest value res
;;place unit
;;return new state
)

(defn tactic-move-unit-to-res [board-state]
;;find highest value res
;;find closest unit
;;move unit towards res
;;return new state
)


(loop [iterate-board-state current-state
       acc-tactics []]
(if (empty? (all-available-tactics))
    acc-tactics
(let [choosen-tactic (first (sort evaluate-board-state (all-available-tactics)))]
(recur choosen-tactic-result
    choosen-tactic))))

;;accumlate best available tactics










;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Alt approach ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


agenda -- priorities for game state (player metrics)
personality -- quantifies how to treat metrics (enemies should be avoided,
strategy -- priorities for board state (board metrics)
tactics -- how to achive board state (considered strategy and personality)



(fn was-agenda-successful?
(loop [goals @goals
       success 0] {:goal (fn [player-state] (>= 20 (:platinum player-state))) :priority [0-3] }
   (recur
 (next goals)
(+ success
  (* ((first (first goal)) player-state) priority))))




personality
{
:aggressive 1-10
:frugal 1-10
:defensive 1-10
:daring 1-10 (don't avoid enemy territory)
}


strategy
{
:maximize-territory 1-10
:get-plat 1-10
:minimize-liberties 1-10
:exploit-weakness
}

(defprotocal tactics
(filter-map [personality, strategy] "Function to adjust graph-map, removing occupied or near occupied territory")

)





ultimately all decisions boil down to moving things or placing things (or neither)





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Heat approach ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
create 'advisors' each evaluating a zone's importance (tactician, banker, defender, ...)
advisors weights for each node sum or multiply to create a heat map
iterate over available actions such as placing new pods or moving units and review which results in biggest gain, apply and eval next action


advisors should use agents to assign priorities to each zone,
advisors evaluation function should take a function to determine how to weight results
higher priority zones should have a lower value for easy sorting


error function to evaluate position (need some absolute)
what is optimal
;;higher stats than opponent
;;most gain among advisors

;;strategy effectiveness is running average of (* strategy-weight relative improvement of board position compared to opponent)




(advise advisor @global-map) ;;returns vector of vectors, one for each game node giving a priority to the nodes [[:node-id :priority-num] [...]...]
(sum-advice)
(while has-more-actions
    (do-best (sort compare (move-nearest :highest-priority-node) (place-near :highest-priority-node))))
(evalutate-game-state-better-worse-and-adjust-advisor-influence)


;;;;TODO
create method to evaluate board and return seq of moves
create method to evaluate board and return seq of placements
create method for adusting advisor influence
create method to fit a curve from data points
create additional advisors
create constants for advisor initial influence (?and how much to adjust influence?)
fill out skeleton of main method
fill out edge vector


;;;;DONE
#working heat map of world
#able to assign a value to each node via an advisor ;;create a priority-source field
#able to adjust a node and nearby nodes based on some function ;;create a scalar field
#able to make a point source and scalar adjustment (w/o side effects) to a map for quick comparison
#create method to accurately distribute income to map nodes

how to use advisor influence (weights source adjustment at node)
how to adjust advisor influence
 get delta for each player


data points


turn


priority-source field
scalar-field



treat each advisor as assigning a temperature source to each node in the world.
model how that temperature source affects surrounding territories
apply temp effect to each territory


summing functions
distance between any two points can be given by seach function

scalar field -- use advisor to assign scalar value to each point
sort world by distance from point
vector field -- use equation to model how a fields scalar value affects priority for itself and surrounding values



;;;;DATA STRUCTURES
;;player -- used to quantify how well a player is doing
{
:income
:territories
:liberties
:resources
}

;;world
{
:id zone-id 0-154
:source-value ;;reset at beginning of every turn
:scalar-value ;;recalculated from nearby source values every turn
:owner ;;id of player controlling this
:open-liberties ;;number of touching nodes owners by non-neutral enemy player
:total-liberties ;;number of bordering nodes, never reset
:income ;;plat income of node each turn, never reset
}



;;;;EQUATIONS
gradient descent
error-calc for gradient descent
importance of individual advisors as a function of time
player evaluation




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Monte Carlo approach ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
after first turn of placing pods on ten highest income sites (or some randomly amongst income sites)
try to play as many games as possible and determine which moves are most likely to result in success, make random moves (possibly weighted towards moving to income squares), model opponent as always moving towards highest empty resource square
